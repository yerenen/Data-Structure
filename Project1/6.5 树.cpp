#if 0
树
1.2 树和森林
1.2.1 树
树（Tree）是n（n >= 0）个结点的有限集。
--若n = 0, 称为空树；
--若n > 0
（1）有且仅有一个特定的称为根（Root）的结点；
（2）其余结点可分为m（m >= 0）个互不相交的有限集T1, T2, T3, ..., Tm.
1.2.2 森林
是m（m >= 0）棵互不相交的树的集合。
1.2.3 树的存储结构
1.2.3.1 双亲表示法
--实现：定义结构数组存放树的结点，每个结点含两个域。
--数据域：存放结点本身信息。
--双亲域：指示本结点的双亲结点在数组中的位置。
--特点：找双亲容易，找孩子难，比较适合找双亲。
#endif
#include<iostream>
#include<stdio.h>
#define MAX_TREE_SIZE 100
using namespace std;
typedef int TElemType;
/*树结点-孩子双亲表示法*/
typedef struct PTNode {
	TElemType data;//存放结点中的数据
	int parent;//双亲位置域
}PTNode;
/*树结构-孩子双亲表示法（用顺序表和数组实现）*/
typedef struct {
	PTNode nodes[MAX_TREE_SIZE];
	int r, n;//根结点的位置和结点个数
}PTree;
#if 0
树
1.2 树和森林
1.2.3 树的存储结构
1.2.3.2 孩子链表
--把每个结点的孩子结点排列起来，看成是一个线性表，用单链表存储。则n个结点有n个孩子链表（叶子的孩子链表为空表）。而n个头指针又组成一个线性表，用顺序表（含n个元素的结构数组）存储。
--特点：找孩子容易，找双亲难，比较适合找孩子。
#endif
/*树-孩子链表-孩子结点结构*/
/*child-next*/
typedef struct CTNode
{
	int child;//孩子结点的下标的位置
	struct CTNode* next;//下一个孩子的地址
}*ChildPtr;
/*树-孩子链表-双亲结点结构*/
/*data-firstchild*/
typedef struct CTNode
{
	TElemType data;
	ChildPtr firstchild;//孩子链表头指针
}*CTBox;
/*树结构-孩子链表（用指针、单链表实现）*/
typedef struct {
	CTBox nodes[MAX_TREE_SIZE];
	int n, r;//结点数和根结点的位置
}CTree;
#if 0
树
1.2 树和森林
1.2.3 树的存储结构
1.2.3.2 孩子兄弟表示法（二叉树表示法，二叉链表表示法）
--实现：用二叉链表作树的存储结构，链表中每个结点的两个指针域分别指向其第一个孩子结点和下一个兄弟结点。
#endif
/*树结构-树的孩子兄弟二叉链表结构*/
typedef struct CSNode {
	TElemType data;//存储数据域
	struct CSNode* firstchild, * nextsibling;
}CSNode,*CSTree;
#if 0
树
1.2 树和森林
1.2.4 树与森林的遍历
1.2.4.1 树的遍历（三种方式）
--先根（次序）遍历：
若树不空，则先访问根结点，然后依次先根遍历各棵子树
--后根（次序）遍历：
若树不空，则先依次后根遍历各棵子树，然后访问根结点
--按层次遍历
若树不空，则自上而下自左至右访问树中每个结点
1.2.4.2 森林的遍历
将森林看作由三个部分构成：
1、森林中第一棵树的根结点
2、森林中第一棵树的子树森林
3、森林中其他树构成的森林
--先序遍历
若森林不空，则
1、访问森林中第一棵树的根结点
2、先序遍历森林中第一棵树的子树森林
3、先序遍历森林中（除第一棵树外）其余树构成的森林
即依次从左至右对森林中的每一棵树进行先序遍历。
--中序遍历
若森林不空，则
1、中序遍历森林中第一棵树的子树森林
2、访问森林中第一棵树的根结点
3、中序遍历森林中（除第一棵树外）其余树构成的森林
即依次从左至右对森林中的每一棵树进行后根遍历。
#endif